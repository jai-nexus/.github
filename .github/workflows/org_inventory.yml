name: Org Inventory
on:
  workflow_dispatch:
    inputs:
      subset:
        description: "Comma-separated repo names (optional)"
        default: ""
      issue_number:
        description: "Issue to comment summary on (optional). Leave blank to skip"
        default: ""

jobs:
  report:
    runs-on: ubuntu-latest
    # Limit the default GITHUB_TOKEN; we use an App token for real work.
    permissions:
      contents: read

    steps:
      - name: Create app token (org-wide, read-only + issues if commenting)
        id: app
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.ORG_APP_ID }}
          private-key: ${{ secrets.ORG_APP_PRIVATE_KEY }}
          owner: jai-nexus
          permission-contents: read
          # enable only if you plan to write an issue comment (step below)
          permission-issues: write
          # (no 'permissions:' JSON; the action wants per-permission inputs)  # <-- important

      - name: Build CSV
        id: inv
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app.outputs.token }}
          result-encoding: string
          script: |
            const org = 'jai-nexus';
            const subset = (`${{ inputs.subset }}` || '')
              .split(',')
              .map(s => s.trim())
              .filter(Boolean);

            // Fetch all repos (handles pagination)
            const repos = await github.paginate('GET /orgs/{org}/repos', {
              org, per_page: 100, type: 'all'
            });

            const targets = subset.length ? repos.filter(r => subset.includes(r.name)) : repos;

            const hdr = ['name','private','has_desc','issues','wiki','projects',
                         'topics','protected_main','vuln_alerts','secret_scanning','push_protection'];
            const rows = [hdr.join(',')];

            for (const r of targets) {
              let protectedMain = false;
              try {
                const br = await github.request('GET /repos/{owner}/{repo}/branches/{branch}', {
                  owner: org, repo: r.name, branch: 'main'
                });
                protectedMain = !!br.data.protected;
              } catch {}

              const sec = r.security_and_analysis || {};
              const line = [
                r.name,
                r.private,
                !!(r.description && r.description.length),
                r.has_issues,
                r.has_wiki,
                r.has_projects,
                (r.topics || []).join(';'),
                protectedMain,
                r.has_vulnerability_alerts ?? '',
                sec.secret_scanning?.status ?? '',
                sec.secret_scanning_push_protection?.status ?? ''
              ].map(v => {
                const s = String(v);
                return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
              }).join(',');

              rows.push(line);
            }

            return rows.join('\n');

      - name: Save artifact
        run: |
          mkdir -p out
          printf "%s" "${{ steps.inv.outputs.result }}" > out/inventory.csv

      - uses: actions/upload-artifact@v4
        with:
          name: org-inventory
          path: out/inventory.csv

      - name: Comment to Issue (optional)
        if: ${{ inputs.issue_number != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app.outputs.token }}
          script: |
            await github.rest.issues.createComment({
              owner: 'jai-nexus',
              repo: 'jai-nexus',
              issue_number: Number('${{ inputs.issue_number }}'),
              body: "Inventory generated. Download artifact **org-inventory** from this run. Next: run **Org Hardener** (dry_run first)."
            });
